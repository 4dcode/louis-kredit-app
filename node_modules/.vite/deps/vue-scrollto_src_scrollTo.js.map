{
  "version": 3,
  "sources": ["../../bezier-easing/src/index.js", "../../vue-scrollto/src/scrollTo.js", "../../vue-scrollto/src/easings.js", "../../vue-scrollto/src/utils.js"],
  "sourcesContent": ["/**\n * https://github.com/gre/bezier-easing\n * BezierEasing - use bezier curve for transition easing function\n * by Ga\u00EBtan Renaudeau 2014 - 2015 \u2013 MIT License\n */\n\n// These values are established by empiricism with tests (tradeoff: performance VS precision)\nvar NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\n\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\n\nvar float32ArraySupported = typeof Float32Array === 'function';\n\nfunction A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }\nfunction B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }\nfunction C (aA1)      { return 3.0 * aA1; }\n\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nfunction calcBezier (aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT; }\n\n// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\nfunction getSlope (aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1); }\n\nfunction binarySubdivide (aX, aA, aB, mX1, mX2) {\n  var currentX, currentT, i = 0;\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n  return currentT;\n}\n\nfunction newtonRaphsonIterate (aX, aGuessT, mX1, mX2) {\n for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n   var currentSlope = getSlope(aGuessT, mX1, mX2);\n   if (currentSlope === 0.0) {\n     return aGuessT;\n   }\n   var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n   aGuessT -= currentX / currentSlope;\n }\n return aGuessT;\n}\n\nfunction LinearEasing (x) {\n  return x;\n}\n\nmodule.exports = function bezier (mX1, mY1, mX2, mY2) {\n  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\n    throw new Error('bezier x values must be in [0, 1] range');\n  }\n\n  if (mX1 === mY1 && mX2 === mY2) {\n    return LinearEasing;\n  }\n\n  // Precompute samples table\n  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n  for (var i = 0; i < kSplineTableSize; ++i) {\n    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n  }\n\n  function getTForX (aX) {\n    var intervalStart = 0.0;\n    var currentSample = 1;\n    var lastSample = kSplineTableSize - 1;\n\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n    --currentSample;\n\n    // Interpolate to provide an initial guess for t\n    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    var guessForT = intervalStart + dist * kSampleStepSize;\n\n    var initialSlope = getSlope(guessForT, mX1, mX2);\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  return function BezierEasing (x) {\n    // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n    if (x === 0) {\n      return 0;\n    }\n    if (x === 1) {\n      return 1;\n    }\n    return calcBezier(getTForX(x), mY1, mY2);\n  };\n};\n", "import BezierEasing from 'bezier-easing'\nimport easings from './easings'\nimport _ from './utils'\n\nconst abortEvents = [\n  'mousedown',\n  'wheel',\n  'DOMMouseScroll',\n  'mousewheel',\n  'keyup',\n  'touchmove',\n]\n\nlet defaults = {\n  container: 'body',\n  duration: 500,\n  lazy: true,\n  easing: 'ease',\n  offset: 0,\n  force: true,\n  cancelable: true,\n  onStart: false,\n  onDone: false,\n  onCancel: false,\n  x: false,\n  y: true,\n}\n\nexport function setDefaults(options) {\n  defaults = Object.assign({}, defaults, options)\n}\n\nexport const scroller = () => {\n  let element // element to scroll to\n  let container // container to scroll\n  let duration // duration of the scrolling\n  let easing // easing to be used when scrolling\n  let lazy // checks the target position at each step\n  let offset // offset to be added (subtracted)\n  let force // force scroll, even if element is visible\n  let cancelable // indicates if user can cancel the scroll or not.\n  let onStart // callback when scrolling is started\n  let onDone // callback when scrolling is done\n  let onCancel // callback when scrolling is canceled / aborted\n  let x // scroll on x axis\n  let y // scroll on y axis\n\n  let initialX // initial X of container\n  let targetX // target X of container\n  let initialY // initial Y of container\n  let targetY // target Y of container\n  let diffX // difference\n  let diffY // difference\n\n  let abort // is scrolling aborted\n\n  let cumulativeOffsetContainer\n  let cumulativeOffsetElement\n\n  let abortEv // event that aborted scrolling\n  let abortFn = e => {\n    if (!cancelable) return\n    abortEv = e\n    abort = true\n  }\n  let easingFn\n\n  let timeStart // time when scrolling started\n  let timeElapsed // time elapsed since scrolling started\n\n  let progress // progress\n\n  function scrollTop(container) {\n    let scrollTop = container.scrollTop\n\n    if (container.tagName.toLowerCase() === 'body') {\n      // in firefox body.scrollTop always returns 0\n      // thus if we are trying to get scrollTop on a body tag\n      // we need to get it from the documentElement\n      scrollTop = scrollTop || document.documentElement.scrollTop\n    }\n\n    return scrollTop\n  }\n\n  function scrollLeft(container) {\n    let scrollLeft = container.scrollLeft\n\n    if (container.tagName.toLowerCase() === 'body') {\n      // in firefox body.scrollLeft always returns 0\n      // thus if we are trying to get scrollLeft on a body tag\n      // we need to get it from the documentElement\n      scrollLeft = scrollLeft || document.documentElement.scrollLeft\n    }\n\n    return scrollLeft\n  }\n\n  function recalculateTargets() {\n    cumulativeOffsetContainer = _.cumulativeOffset(container)\n    cumulativeOffsetElement = _.cumulativeOffset(element)\n\n    if (x) {\n      targetX =\n        cumulativeOffsetElement.left - cumulativeOffsetContainer.left + offset\n      diffX = targetX - initialX\n    }\n    if (y) {\n      targetY =\n        cumulativeOffsetElement.top - cumulativeOffsetContainer.top + offset\n      diffY = targetY - initialY\n    }\n  }\n\n  function step(timestamp) {\n    if (abort) return done()\n    if (!timeStart) timeStart = timestamp\n\n    // When a site has a lot of media that can be loaded asynchronously,\n    // the targetY/targetX may end up in the wrong place during scrolling.\n    // So we will check this at each step\n    if (!lazy) {\n      recalculateTargets()\n    }\n\n    timeElapsed = timestamp - timeStart\n\n    progress = Math.min(timeElapsed / duration, 1)\n    progress = easingFn(progress)\n\n    topLeft(container, initialY + diffY * progress, initialX + diffX * progress)\n\n    timeElapsed < duration ? window.requestAnimationFrame(step) : done()\n  }\n\n  function done() {\n    if (!abort) topLeft(container, targetY, targetX)\n    timeStart = false\n\n    _.off(container, abortEvents, abortFn)\n    if (abort && onCancel) onCancel(abortEv, element)\n    if (!abort && onDone) onDone(element)\n  }\n\n  function topLeft(element, top, left) {\n    if (y) element.scrollTop = top\n    if (x) element.scrollLeft = left\n    if (element.tagName.toLowerCase() === 'body') {\n      // in firefox body.scrollTop doesn't scroll the page\n      // thus if we are trying to scrollTop on a body tag\n      // we need to scroll on the documentElement\n      if (y) document.documentElement.scrollTop = top\n      if (x) document.documentElement.scrollLeft = left\n    }\n  }\n\n  function scrollTo(target, _duration, options = {}) {\n    if (typeof _duration === 'object') {\n      options = _duration\n    } else if (typeof _duration === 'number') {\n      options.duration = _duration\n    }\n\n    element = _.$(target)\n\n    if (!element) {\n      return console.warn(\n        '[vue-scrollto warn]: Trying to scroll to an element that is not on the page: ' +\n          target\n      )\n    }\n\n    container = _.$(options.container || defaults.container)\n    duration = options.hasOwnProperty('duration')\n      ? options.duration\n      : defaults.duration\n    lazy = options.hasOwnProperty('lazy') ? options.lazy : defaults.lazy\n    easing = options.easing || defaults.easing\n    offset = options.hasOwnProperty('offset') ? options.offset : defaults.offset\n    force = options.hasOwnProperty('force')\n      ? options.force !== false\n      : defaults.force\n    cancelable = options.hasOwnProperty('cancelable')\n      ? options.cancelable !== false\n      : defaults.cancelable\n    onStart = options.onStart || defaults.onStart\n    onDone = options.onDone || defaults.onDone\n    onCancel = options.onCancel || defaults.onCancel\n    x = options.x === undefined ? defaults.x : options.x\n    y = options.y === undefined ? defaults.y : options.y\n\n    if (typeof offset === 'function') {\n      offset = offset(element, container)\n    }\n\n    initialX = scrollLeft(container)\n    initialY = scrollTop(container)\n\n    // calculates cumulative offsets and targetX/Y + diffX/Y\n    recalculateTargets()\n\n    abort = false\n\n    if (!force) {\n      // When the container is the default (body) we need to use the viewport\n      // height, not the entire body height\n      const containerHeight =\n        container.tagName.toLowerCase() === 'body'\n          ? document.documentElement.clientHeight || window.innerHeight\n          : container.offsetHeight\n      const containerTop = initialY\n      const containerBottom = containerTop + containerHeight\n      const elementTop = targetY - offset\n      const elementBottom = elementTop + element.offsetHeight\n      if (elementTop >= containerTop && elementBottom <= containerBottom) {\n        // make sure to call the onDone callback even if there is no need to\n        // scroll the container. Fixes #111 (ref #118)\n        if (onDone) onDone(element)\n        return\n      }\n    }\n\n    if (onStart) onStart(element)\n\n    if (!diffY && !diffX) {\n      if (onDone) onDone(element)\n      return\n    }\n\n    if (typeof easing === 'string') {\n      easing = easings[easing] || easings['ease']\n    }\n\n    easingFn = BezierEasing.apply(BezierEasing, easing)\n\n    _.on(container, abortEvents, abortFn, { passive: true })\n\n    window.requestAnimationFrame(step)\n\n    return () => {\n      abortEv = null\n      abort = true\n    }\n  }\n\n  return scrollTo\n}\n\nconst _scroller = scroller()\nexport default _scroller\n", "export default {\n  ease: [0.25, 0.1, 0.25, 1.0],\n  linear: [0.0, 0.0, 1.0, 1.0],\n  'ease-in': [0.42, 0.0, 1.0, 1.0],\n  'ease-out': [0.0, 0.0, 0.58, 1.0],\n  'ease-in-out': [0.42, 0.0, 0.58, 1.0],\n}\n", "// https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md#feature-detection\nlet supportsPassive = false\ntry {\n  let opts = Object.defineProperty({}, 'passive', {\n    get: function() {\n      supportsPassive = true\n    },\n  })\n  window.addEventListener('test', null, opts)\n} catch (e) {}\n\nexport default {\n  $(selector) {\n    if (typeof selector !== 'string') {\n      return selector\n    }\n    return document.querySelector(selector)\n  },\n  on(element, events, handler, opts = { passive: false }) {\n    if (!(events instanceof Array)) {\n      events = [events]\n    }\n    for (let i = 0; i < events.length; i++) {\n      element.addEventListener(\n        events[i],\n        handler,\n        supportsPassive ? opts : false\n      )\n    }\n  },\n  off(element, events, handler) {\n    if (!(events instanceof Array)) {\n      events = [events]\n    }\n    for (let i = 0; i < events.length; i++) {\n      element.removeEventListener(events[i], handler)\n    }\n  },\n  cumulativeOffset(element) {\n    let top = 0\n    let left = 0\n\n    do {\n      top += element.offsetTop || 0\n      left += element.offsetLeft || 0\n      element = element.offsetParent\n    } while (element)\n\n    return {\n      top: top,\n      left: left,\n    }\n  },\n}\n"],
  "mappings": "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",
  "names": ["BezierEasing", "container", "scrollTop", "scrollLeft", "element", "BezierEasing"]
}
