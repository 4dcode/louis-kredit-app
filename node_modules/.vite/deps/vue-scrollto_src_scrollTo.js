import {
  __commonJS,
  __toESM
} from "./chunk-IN47U6CF.js";

// node_modules/bezier-easing/src/index.js
var require_src = __commonJS({
  "node_modules/bezier-easing/src/index.js"(exports, module) {
    var NEWTON_ITERATIONS = 4;
    var NEWTON_MIN_SLOPE = 1e-3;
    var SUBDIVISION_PRECISION = 1e-7;
    var SUBDIVISION_MAX_ITERATIONS = 10;
    var kSplineTableSize = 11;
    var kSampleStepSize = 1 / (kSplineTableSize - 1);
    var float32ArraySupported = typeof Float32Array === "function";
    function A(aA1, aA2) {
      return 1 - 3 * aA2 + 3 * aA1;
    }
    function B(aA1, aA2) {
      return 3 * aA2 - 6 * aA1;
    }
    function C(aA1) {
      return 3 * aA1;
    }
    function calcBezier(aT, aA1, aA2) {
      return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;
    }
    function getSlope(aT, aA1, aA2) {
      return 3 * A(aA1, aA2) * aT * aT + 2 * B(aA1, aA2) * aT + C(aA1);
    }
    function binarySubdivide(aX, aA, aB, mX1, mX2) {
      var currentX, currentT, i = 0;
      do {
        currentT = aA + (aB - aA) / 2;
        currentX = calcBezier(currentT, mX1, mX2) - aX;
        if (currentX > 0) {
          aB = currentT;
        } else {
          aA = currentT;
        }
      } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
      return currentT;
    }
    function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
      for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
        var currentSlope = getSlope(aGuessT, mX1, mX2);
        if (currentSlope === 0) {
          return aGuessT;
        }
        var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
        aGuessT -= currentX / currentSlope;
      }
      return aGuessT;
    }
    function LinearEasing(x) {
      return x;
    }
    module.exports = function bezier(mX1, mY1, mX2, mY2) {
      if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
        throw new Error("bezier x values must be in [0, 1] range");
      }
      if (mX1 === mY1 && mX2 === mY2) {
        return LinearEasing;
      }
      var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
      for (var i = 0; i < kSplineTableSize; ++i) {
        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
      }
      function getTForX(aX) {
        var intervalStart = 0;
        var currentSample = 1;
        var lastSample = kSplineTableSize - 1;
        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
          intervalStart += kSampleStepSize;
        }
        --currentSample;
        var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
        var guessForT = intervalStart + dist * kSampleStepSize;
        var initialSlope = getSlope(guessForT, mX1, mX2);
        if (initialSlope >= NEWTON_MIN_SLOPE) {
          return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
        } else if (initialSlope === 0) {
          return guessForT;
        } else {
          return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
        }
      }
      return function BezierEasing2(x) {
        if (x === 0) {
          return 0;
        }
        if (x === 1) {
          return 1;
        }
        return calcBezier(getTForX(x), mY1, mY2);
      };
    };
  }
});

// node_modules/vue-scrollto/src/scrollTo.js
var import_bezier_easing = __toESM(require_src());

// node_modules/vue-scrollto/src/easings.js
var easings_default = {
  ease: [0.25, 0.1, 0.25, 1],
  linear: [0, 0, 1, 1],
  "ease-in": [0.42, 0, 1, 1],
  "ease-out": [0, 0, 0.58, 1],
  "ease-in-out": [0.42, 0, 0.58, 1]
};

// node_modules/vue-scrollto/src/utils.js
var supportsPassive = false;
try {
  let opts = Object.defineProperty({}, "passive", {
    get: function() {
      supportsPassive = true;
    }
  });
  window.addEventListener("test", null, opts);
} catch (e) {
}
var utils_default = {
  $(selector) {
    if (typeof selector !== "string") {
      return selector;
    }
    return document.querySelector(selector);
  },
  on(element, events, handler, opts = { passive: false }) {
    if (!(events instanceof Array)) {
      events = [events];
    }
    for (let i = 0; i < events.length; i++) {
      element.addEventListener(
        events[i],
        handler,
        supportsPassive ? opts : false
      );
    }
  },
  off(element, events, handler) {
    if (!(events instanceof Array)) {
      events = [events];
    }
    for (let i = 0; i < events.length; i++) {
      element.removeEventListener(events[i], handler);
    }
  },
  cumulativeOffset(element) {
    let top = 0;
    let left = 0;
    do {
      top += element.offsetTop || 0;
      left += element.offsetLeft || 0;
      element = element.offsetParent;
    } while (element);
    return {
      top,
      left
    };
  }
};

// node_modules/vue-scrollto/src/scrollTo.js
var abortEvents = [
  "mousedown",
  "wheel",
  "DOMMouseScroll",
  "mousewheel",
  "keyup",
  "touchmove"
];
var defaults = {
  container: "body",
  duration: 500,
  lazy: true,
  easing: "ease",
  offset: 0,
  force: true,
  cancelable: true,
  onStart: false,
  onDone: false,
  onCancel: false,
  x: false,
  y: true
};
function setDefaults(options) {
  defaults = Object.assign({}, defaults, options);
}
var scroller = () => {
  let element;
  let container;
  let duration;
  let easing;
  let lazy;
  let offset;
  let force;
  let cancelable;
  let onStart;
  let onDone;
  let onCancel;
  let x;
  let y;
  let initialX;
  let targetX;
  let initialY;
  let targetY;
  let diffX;
  let diffY;
  let abort;
  let cumulativeOffsetContainer;
  let cumulativeOffsetElement;
  let abortEv;
  let abortFn = (e) => {
    if (!cancelable)
      return;
    abortEv = e;
    abort = true;
  };
  let easingFn;
  let timeStart;
  let timeElapsed;
  let progress;
  function scrollTop(container2) {
    let scrollTop2 = container2.scrollTop;
    if (container2.tagName.toLowerCase() === "body") {
      scrollTop2 = scrollTop2 || document.documentElement.scrollTop;
    }
    return scrollTop2;
  }
  function scrollLeft(container2) {
    let scrollLeft2 = container2.scrollLeft;
    if (container2.tagName.toLowerCase() === "body") {
      scrollLeft2 = scrollLeft2 || document.documentElement.scrollLeft;
    }
    return scrollLeft2;
  }
  function recalculateTargets() {
    cumulativeOffsetContainer = utils_default.cumulativeOffset(container);
    cumulativeOffsetElement = utils_default.cumulativeOffset(element);
    if (x) {
      targetX = cumulativeOffsetElement.left - cumulativeOffsetContainer.left + offset;
      diffX = targetX - initialX;
    }
    if (y) {
      targetY = cumulativeOffsetElement.top - cumulativeOffsetContainer.top + offset;
      diffY = targetY - initialY;
    }
  }
  function step(timestamp) {
    if (abort)
      return done();
    if (!timeStart)
      timeStart = timestamp;
    if (!lazy) {
      recalculateTargets();
    }
    timeElapsed = timestamp - timeStart;
    progress = Math.min(timeElapsed / duration, 1);
    progress = easingFn(progress);
    topLeft(container, initialY + diffY * progress, initialX + diffX * progress);
    timeElapsed < duration ? window.requestAnimationFrame(step) : done();
  }
  function done() {
    if (!abort)
      topLeft(container, targetY, targetX);
    timeStart = false;
    utils_default.off(container, abortEvents, abortFn);
    if (abort && onCancel)
      onCancel(abortEv, element);
    if (!abort && onDone)
      onDone(element);
  }
  function topLeft(element2, top, left) {
    if (y)
      element2.scrollTop = top;
    if (x)
      element2.scrollLeft = left;
    if (element2.tagName.toLowerCase() === "body") {
      if (y)
        document.documentElement.scrollTop = top;
      if (x)
        document.documentElement.scrollLeft = left;
    }
  }
  function scrollTo(target, _duration, options = {}) {
    if (typeof _duration === "object") {
      options = _duration;
    } else if (typeof _duration === "number") {
      options.duration = _duration;
    }
    element = utils_default.$(target);
    if (!element) {
      return console.warn(
        "[vue-scrollto warn]: Trying to scroll to an element that is not on the page: " + target
      );
    }
    container = utils_default.$(options.container || defaults.container);
    duration = options.hasOwnProperty("duration") ? options.duration : defaults.duration;
    lazy = options.hasOwnProperty("lazy") ? options.lazy : defaults.lazy;
    easing = options.easing || defaults.easing;
    offset = options.hasOwnProperty("offset") ? options.offset : defaults.offset;
    force = options.hasOwnProperty("force") ? options.force !== false : defaults.force;
    cancelable = options.hasOwnProperty("cancelable") ? options.cancelable !== false : defaults.cancelable;
    onStart = options.onStart || defaults.onStart;
    onDone = options.onDone || defaults.onDone;
    onCancel = options.onCancel || defaults.onCancel;
    x = options.x === void 0 ? defaults.x : options.x;
    y = options.y === void 0 ? defaults.y : options.y;
    if (typeof offset === "function") {
      offset = offset(element, container);
    }
    initialX = scrollLeft(container);
    initialY = scrollTop(container);
    recalculateTargets();
    abort = false;
    if (!force) {
      const containerHeight = container.tagName.toLowerCase() === "body" ? document.documentElement.clientHeight || window.innerHeight : container.offsetHeight;
      const containerTop = initialY;
      const containerBottom = containerTop + containerHeight;
      const elementTop = targetY - offset;
      const elementBottom = elementTop + element.offsetHeight;
      if (elementTop >= containerTop && elementBottom <= containerBottom) {
        if (onDone)
          onDone(element);
        return;
      }
    }
    if (onStart)
      onStart(element);
    if (!diffY && !diffX) {
      if (onDone)
        onDone(element);
      return;
    }
    if (typeof easing === "string") {
      easing = easings_default[easing] || easings_default["ease"];
    }
    easingFn = import_bezier_easing.default.apply(import_bezier_easing.default, easing);
    utils_default.on(container, abortEvents, abortFn, { passive: true });
    window.requestAnimationFrame(step);
    return () => {
      abortEv = null;
      abort = true;
    };
  }
  return scrollTo;
};
var _scroller = scroller();
var scrollTo_default = _scroller;
export {
  scrollTo_default as default,
  scroller,
  setDefaults
};
//# sourceMappingURL=vue-scrollto_src_scrollTo.js.map
